head	1.1;
access;
symbols;
locks; strict;
comment	@ * @;


1.1
date	98.08.08.11.36.05;	author peterj;	state Exp;
branches;
next	;


desc
@CMATH 1989 code
@


1.1
log
@Initial revision
@
text
@/* stint.c
   Ordinary Differential Equation solver for stiff equations.
   */

/************************************************/
/*                                              */
/*  CMATH.  Copyright (c) 1989 Design Software  */
/*                                              */
/************************************************/

#include "cmath.h"
#if (STDLIBH)
#include <stdlib.h>
#endif
#include <stdio.h>
#include <math.h>

#ifndef NULL
#define  NULL  0
#endif


/*-----------------------------------------------------------------*/

/* More Global Definitions */

static int ndim;
static int nstep, ninvs;
double ***y;               /* y[8][4][ndim]   */
double **ydot;             /* ydot[4][ndim]   */
double **saved;            /* saved[13][ndim] */
double *rj;                /* rj[ndim * ndim] */
double *rw;                /* rw[ndim * ndim] */
double *ymax;              /* ymax[ndim]      */
int    *ipiv;              /* ipiv[ndim]      */

static double b[82], c[16], perr[9], pc[16], pd[7];
static double uround, sqrtur;
static int    index[7][2];


/* These macros are used in function stint2() */
#define    MAX(a,b)   ( ((a) < (b)) ? (b) : (a) )
#define    MIN(a,b)   ( ((a) < (b)) ? (a) : (b) )

/*-----------------------------------------------------------------*/

#if (PROTOTYPE)

int stint0(int n, int *flag)

#else

int stint0(n, flag)
int n, *flag;

#endif

/* Purpose ...
   -------
   Allocate workspace for stint1() and stint2().  Set up constants.

   Input ...
   -----
   n     : number of simultaneous ODEs

   Output ...
   ------
   flag  : Status indicator.
           flag = 0,  no problems
           flag = 1,  n <= 0
           flag = 2,  could not allocate memory

   This C code written by ...  Peter & Nigel,
   ----------------------      Design Software,
                               42 Gubberley St,
                               Kenmore, 4069,
                               Australia.

   Version ... 1.0  May 1989
   -------     1.1  Dec 1989, fixed memory allocation/deallocation

   Notes ...
   -----
   (1) stint0() must be called successfully before using stint1()
       or stint2().
*/

{
int i, j;

ndim = n;

*flag = 0;

if (ndim < 1)
   {
   *flag = 1;
   return (0);
   }

y     = (double ***) NULL;
ydot  = (double **) NULL;
saved = (double **) NULL;
rj    = (double *) NULL;
rw    = (double *) NULL;
ymax  = (double *) NULL;
ipiv  = (int *) NULL;

y = (double ***) malloc(8 * sizeof(double **));
if (y == NULL)
   {
   *flag = 2;
   return (0);
   }
for (i = 0; i < 8; ++i) y[i] = (double **) NULL;
for (i = 0; i < 8; ++i)
   {
   y[i] = (double **) malloc(4 * sizeof(double *));
   if (y[i] == NULL)
      {
      *flag = 2;
      return (0);
      }
   for (j = 0; j < 4; ++j) y[i][j] = (double *) NULL;
   for (j = 0; j < 4; ++j)
      {
      y[i][j] = (double *) malloc(ndim * sizeof(double));
      if (y[i][j] == NULL)
         {
         *flag = 2;
         return (0);
         }
      }
   }

ydot = (double **) malloc(4 * sizeof(double *));
if (ydot == NULL)
   {
   *flag = 2;
   return (0);
   }
for (j = 0; j < 4; ++j) ydot[j] = (double *) NULL;
for (j = 0; j < 4; ++j)
   {
   ydot[j] = (double *) malloc(ndim * sizeof(double));
   if (ydot[j] == NULL)
      {
      *flag = 2;
      return (0);
      }
   }

saved = (double **) malloc(13 * sizeof(double *));
if (saved == NULL)
   {
   *flag = 2;
   return (0);
   }
for (j = 0; j < 13; ++j) saved[j] = (double *) NULL;
for (j = 0; j < 13; ++j)
   {
   saved[j] = (double *) malloc(ndim * sizeof(double));
   if (saved[j] == NULL)
      {
      *flag = 2;
      return (0);
      }
   }

rj = (double *) malloc(ndim * ndim * sizeof(double));
if (rj == NULL)
   {
   *flag = 2;
   return (0);
   }

rw = (double *) malloc(ndim * ndim * sizeof(double));
if (rw == NULL)
   {
   *flag = 2;
   return (0);
   }

ymax = (double *) malloc(ndim * sizeof(double));
if (ymax == NULL)
   {
   *flag = 2;
   return (0);
   }

ipiv = (int *) malloc(ndim * sizeof(int));
if (ipiv == NULL)
   {
   *flag = 2;
   return (0);
   }

/*---- constants ----*/

/* seven of eight data statements contain
   array names and various  lines of code
   include subscript expressions

   the array index holds pointers and constants for the various
   order methods.  for nq=1,...,7 the entries are as follows
    index[nq-1][1]   base index for b array (h*dy predictor).
    index[nq-1][2]   base index for c array (corrector).
*/
index[0][0] = 1;
index[1][0] = 2;
index[2][0] = 4;
index[3][0] = 11;
index[4][0] = 20;
index[5][0] = 38;
index[6][0] = 59;
index[0][1] = 1;
index[1][1] = 2;
index[2][1] = 3;
index[3][1] = 5;
index[4][1] = 7;
index[5][1] = 10;
index[6][1] = 14;

/* The coefficients in the perr array are used in the error test,
   the first time it is performed, as well as in the step-size/order
   selection segment. perr[i] = 1/d[i], i=1,...,7, where
   d[i] is the discretization error constant corresponding to the
   second pass of the integration cycle of order i. perr[0] and
   perr[8] are defined solely for programming ease. They are not
   used.
*/
perr[0] = 1.0;
perr[1] = 1.0;
perr[2] = 1.92857;
perr[3] = 2.78161;
perr[4] = 3.56735;
perr[5] = 4.29497;
perr[6] = 4.9065;
perr[7] = 5.6066;
perr[8] = 1.0;

/* The coefficients in the array pc are used both in the convergence
   and error tests. They are the reciprocal values of the
   discretization error constants for equations constituting the
   methods of order 1 thru 7.
*/
pc[0] = 2.0;
pc[1] = 4.5;
pc[2] = 7.3333;
pc[3] = 6.0;
pc[4] = 10.4167;
pc[5] = 9.3;
pc[6] = 13.7;
pc[7] = 13.8687;
pc[8] = 9.6904;
pc[9] = 17.15;
pc[10] = 16.9504;
pc[11] = 17.4349;
pc[12] = 9.472;
pc[13] = 20.7429;
pc[14] = 15.921;
pc[15] = 14.7809;

/* The coefficients appearing in the array pd are used in the testing
   of the "outdatedness" of the array rw.  The pd[i-1] element contains
   the average value of the coefficients in array c corresponding to
   order i.
*/
pd[0] = 1.0;
pd[1] = 0.6667;
pd[2] = 0.6061;
pd[3] = 0.4981;
pd[4] = 0.4644;
pd[5] = 0.4368;
pd[6] = 0.412;

/* The constant uround should be set equal to the unit round-off
   for the machine.  The constant sqrtur should be set equal to the
   square root of uround.
*/
uround = EPSILON;
sqrtur = sqrt(uround);

/* the coefficients appearing in the next data statements for the
   b array should be defined to the maximum accuracy permitted by
   the machine. they are, in the order specified,...
    1
    -2, 3
    -9/2, -5/4, 11/2
    -15/2, -3/4, 13/2, 2
    -22/3, -8/3, -17/18, 25/3
    -9, -9/4, -7/8, 35/4, 5/4
    -125/12, -101/24, -71/36, -37/48, 137/12
    -123/24, -1001/240, -707/360, -123/160, 1373/120, 1/10
    -57/4, -25/8, -17/10, -169/240, 61/5, -1/20, 31/10
    -137/10, -117/20, -46/15, -191/120, -197/300, 147/10
    -353/25, -571/100, -1819/600, -79/50, -3919/6000, 1477/100, 7/20
    -3529/200, -1889/400, -1609/600, -3527/2400, -931/1500, 3079/200,
        -3/20, 17/5
    -343/20, -303/40, -253/60, -589/240, -101/75, -23/40, 363/20
    -266/15, -221/30, -749/180, -73/30, -803/600, -103/180, 547/30,
        1/2
    -1316/75, -1151/150, -3689/900, -121/50, -4003/3000, -257/450,
        2737/150, -1/5, 1/2
*/
b[0] = 1.0;
b[1] = -2.0;
b[2] = 3.0;
b[3] = -4.5;
b[4] = -1.25;
b[5] = 5.5;
b[6] = -7.5;
b[7] = -.75;
b[8] = 6.5;
b[9] = 2.0;
b[10] = -7.3333333333333333;
b[11] = -2.6666666666666667;
b[12] = -.94444444444444444;
b[13] = 8.3333333333333333;
b[14] = -9.0;
b[15] = -2.25;
b[16] = -.875;
b[17] = 8.75;
b[18] = 1.25;
b[19] = -10.416666666666667;
b[20] = -4.2083333333333333;
b[21] = -1.9722222222222222;
b[22] = -.77083333333333333;
b[23] = 11.416666666666667;
b[24] = -10.541666666666667;
b[25] = -4.1708333333333333;
b[26] = -1.9638888888888889;
b[27] = -.76875;
b[28] = 11.441666666666667;
b[29] = 0.1;
b[30] = -14.25;
b[31] = -3.125;
b[32] = -1.7;
b[33] = -.70416666666666667;
b[34] = 12.2;
b[35] = -.05;
b[36] = 3.1;
b[37] = -13.7;
b[38] = -5.85;
b[39] = -3.0666666666666667;
b[40] = -1.5916666666666667;
b[41] = -.65666666666666667;
b[42] = 14.7;
b[43] = -14.12;
b[44] = -5.71;
b[45] = -3.0316666666666667;
b[46] = -1.58;
b[47] = -.65316666666666667;

b[48] = 14.77;
b[49] = 0.35;
b[50] = -17.645;
b[51] = -4.7225;
b[52] = -2.6816666666666667;
b[53] = -1.4695833333333333;
b[54] = -.62066666666666667;
b[55] = 15.395;
b[56] = -.15;
b[57] = 3.4;
b[58] = -17.15;
b[59] = -7.575;
b[60] = -4.2166666666666667;
b[61] = -2.4541666666666667;
b[62] = -1.3466666666666667;
b[63] = -.575;
b[64] = 18.15;
b[65] = -17.733333333333333;
b[66] = -7.3666666666666667;
b[67] = -4.1611111111111111;
b[68] = -2.4333333333333333;
b[69] = -1.3383333333333333;
b[70] = -.57222222222222222;
b[71] = -18.23333333333333;
b[72] = 0.5;
b[73] = -17.546666666666667;
b[74] = -7.6733333333333333;
b[75] = -4.0988888888888889;
b[76] = -2.42;
b[77] = -1.3343333333333333;
b[78] = -.57111111111111111;
b[79] = 18.246666666666667;
b[80] = -0.2;
b[81] = 0.5;

/* The coefficients appearing the the next data statements for the
   c array should be defined to the maximum accuracy permitted by
   the machine.  They are, in the order specified,...
    -1
    -2/3
    -6/11, -2/3
    -12/25, -16/31
    -60/137, -600/1373, -100/193
    -20/49, -120/293, -75/184, -1200/2299
    -140/363, -60/143, -1050/2437
*/
c[0] = -1.0;
c[1] = -.66666666666666667;
c[2] = -.545454545454545;
c[3] = -.66666666666666667;
c[4] = -.48;
c[5] = -.51612903225806452;
c[6] = -.43796520437956204;
c[7] = -.43699927166788056;
c[8] = -.51813471502590674;
c[9] = -.40816326530612245;
c[10] = -.40955631399317406;
c[11] = -.40760869565217391;
c[12] = -.52196607220530666;
c[13] = -.38567493112947659;
c[14] = -.41958041958041958;
c[15] = -.43085761181780879;

return (0);
}

/*-----------------------------------------------------------------*/

/* Easy to use interface */

#if (PROTOTYPE)

int stint1 (int n, double z[],
            double *t, double tout,
            double hi, double error,
            int mf, int *nfe, int *nje, int *flag,
            int (*deriv)(int n, double t, double y[], double dy[]),
            int (*jacob)(int n, double t, double y[], double rj[]) )

#else

int stint1 (n, z, t, tout, hi, error, mf,
            nfe, nje, flag, deriv, jacob)

int     n;
double  z[], *t, tout, hi, error;
int     mf, *nfe, *nje, *flag;
int     (*deriv)(), (*jacob)();

#endif

/* Purpose ...
   -------
   Easy to use version of STINT: a stiff differential equation
   integrator.  A set of ODE's is integrated from t to tout
   using a cyclic composite multistep method as described in [1]
   and [2].  The algorithm includes variable step-size and variable
   order integration of the ODE's and tries to take as large a step
   size as possible without producing a single step error larger
   than that requested.

   Input ...
   -----
   n       : order of system.  Equations are numbered 0 .. n-1.
   t,tout  : initial,final values of independent variable,t
   hi      : initial step size.
   error   : relative error tolerance requested.
   mf      : method flag.
             = 1, jacobian must be supplied in function jacob().
             = 2, no jacobian need be supplied.
   z       : initial value of dependent variables, z[i], i=0 .. n-1.
	     declared as ... double z[n].

   Output ...
   ------
   t       : (=tout), value of independent variable.
   z       : value of dependent variables at t.
   nfe     : number of derivative evaluations
   nje     : number of jacobian evaluations
   flag    : completion code.
	     >  0  then the integration was successful.
             = -2, -3, -4 then 2, 3 or 4 mesh points respectively,
	 	   have been computed with abs(h) = 0.01 abs(hi) but
		   the requested error was not achieved. (h is the
		   step size used within stint2().)
	     = -5, the requested error was smaller than can be
		   handled for this problem
	     = -6, corrector convergence could not be achieved for
		   abs(h) > 0.01 abs(hi).

   Workspace ...
   ---------
   Allocated as global space by stint0().
   y       : double y[8][4][ndim]
   ydot    : double ydot[4][ndim]
   saved   : double saved[13][ndim]
   rj      : double rj[ndim * ndim]
   rw      : double rw[ndim * ndim]
   ymax    : double ymax[ndim]
   ipiv    : int    ipiv[ndim]

   Global Variables ...
   ----------------
   nstep   : number of steps taken
   ninvs   : number of LU decompositions

   User supplied functions ...
   -----------------------
   int deriv(n, t, y, dy)
   int n; double t, y[], dy[];
      evaluates the derivatives of the dependent variables y[i],
      i=0 .. n-1 with respect to t and stores the result in
      dy[i], i=0 .. n-1.

   int jacob(n, t, y, rj)
   int n; double t, y[], rj[];
      evaluates the partial derivatives of the differential equations
      at the values y[i] and t and stores the result in rj[].
      Thus rj[i*n + j] is the partial of dy[i] with respect to y[j]
      for i,j = 0 .. n-1.  If the analytic expressions for the partial
      derivatives are not available, their approximate values can be
      obtained by numerical differencing (see parameter mf).  In this
      case function jacob() may be

      int jacob(n, t, y, rj)
      int n;
      double t, y[], rj[];
      {
      return (0);
      }

   This C code written by ...  Peter & Nigel,
   ----------------------      Design Software,
                               42 Gubberley St,
                               Kenmore, 4069,
                               Australia.

   Version ... 1.0 April-May 1988
   -------     2.0 May 1989    Memory allocation
                               separate compilation

   Notes ...
   -----
   (1) This C code adapted from the original FORTRAN code [1]
   (2) Requires the functions decomp() and solve() from the
       CMATH library.
   (3) For more details on the Input/Output and workspace variables
       see the documentation in function stint2().

   References ...
   ----------
   [1] J.M Tendler, T.A. Bickart & Z Picel 1978 : "Algorithm 534
       STINT: STiff (differential equations) INTegrator".  Collected
       Algorithms of the ACM.
   [2] J.M. Tendler, T.A. Bickart & Z. Picel 1978 : "A stiffly stable
       integration process using cyclic composite methods".  ACM
       Trans. Math. Software Vol.4 (4), 339-368.

*/
{  /* begin function stint1 */
double hmax, hnext, hmin, h0, ts, s, d;
int    i, j, flagp1, ii, maxder, jstart;
int    finished;
int    knext, ind;

/*  set the normalizing vector matrix ymax. */
for (i = 0; i < n; ++i)
   {
   ymax[i] = MAX(fabs(z[i]),1.0);
   y[0][0][i] = z[i];
   }
hmax     = (tout - *t) * 10.0;
hnext    = hi;
hmin     = hi * 0.01;
maxder   = 7;
jstart   = 0;
finished = 0;
nstep    = 0;
ninvs    = 0;
*nje     = 0;
*nfe     = 0;

/* call stint as many times as necessary to reach the finish
   point  */

do {
   stint2 (n, t, &h0, &hnext, hmin, hmax, error, nfe, nje,
           flag, &knext, &jstart, maxder, mf, deriv, jacob);
   if (*flag < 0) return (1);   /* stint failed */
   flagp1 = *flag + 1;

   /* check whether the computed solution reached beyond the
   interpolation point tout. */
   ii = 0;
   for (i = 1; i <= flagp1; ++i)
      {
      ++ii;
      ts = tout - *t + h0 * (i - 1);
      if (ts >= 0.0)
         {
	 finished = (i > 1);  /* at least one mesh point was
				 computed past the finish point */
	 break;
         }
      }
} while (!finished);

/* The solution reached beyond tout.
   Perform interpolation at tout.
*/
ind = *flag + 3 - ii;
if (ii == 2) ind = 1;
s = (ts - h0) / h0;
*t = tout;
for (i = 0; i < n; ++i)
   {
   d = 1.0;
   z[i] = y[0][ind-1][i];
   for (j = 1; j <= jstart; ++j)
      {
      d = d * ((j - 1) + s) / j;
      z[i] += d * y[j][ind-1][i];
      }
   }

return (0);
} /* end of stint1() */

/*-----------------------------------------------------------------*/

/* This is the not-so-easy-to-use version of stint.
   The function stint1() is used as the usual interface.
*/

#if (PROTOTYPE)

int stint2 (int n, double *t, double *h, double *hnext,
            double hmin, double hmax, double eps,
            int *nfe, int *nje, int *kflag, int *knext,
            int *jstart, int maxord, int mf,
            int (*deriv)(int n, double t, double y[], double dy[]),
            int (*jacob) (int n, double t, double y[], double rj[]) )

#else

int stint2 (n, t, h, hnext, hmin, hmax, eps,
            nfe, nje, kflag, knext, jstart, maxord, mf,
            deriv, jacob)

int    n;
double *t;
double *h, *hnext, hmin, hmax, eps;
int    *nfe, *nje, *kflag, *knext, *jstart, maxord, mf;
int    (*deriv)(), (*jacob)();

#endif

/* Purpose ...
   -------
   This program integrates a set of n first order ordinary
   differential equations.  A block of three or four solution points,
   each separated by a step-size h, is computed at each call. The
   step-size magnitude may be specified by the user at each call.
   Alternatively, it may be increased or decreased by stint2 within
   the range  abs(hmin) to  abs(hmax),
   in order to achieve as large a step as possible, while not
   commiting a single step error which is larger than eps in the
   rms norm, where each component of the error vector is divided by
   the corresponding component of ymax.

   Variables ...
   ---------
   The global variables y[][][], ydot[][] and ymax[] need to be
   allocated by the function stint0() before calling stint1() or
   stint2().  Temporary storage space is also allocated as the
   arrays ipiv, rj, rw, and saved.  A description of major
   variables follows.

   The array ipiv holds a vector integer values for the matrix
   decomposition routine. The arrays rj and rw are used to hold
   matrices for matrix decomposition.

   The array saved is partitioned as follows ...

   saved(j,i)     0 <= j <= 7 and 0 <= i <= n-1 is used to save
                  y(i,j) in case a step (and hence the whole cycle)
                  has to be repeated.
   saved(8,i)     1 <= i <= n is used to store the derivative of the
                  i-th dependent variable scaled by h.
   saved[9][i]    is used to store the derivatives as they are
                  computed by deriv for the corrector. It is also
                  accessed as a complete array saved[9].
                  In addition it is used in the error control test.
   saved[10][i]   is used to hold the correction terms for the entire
                  corrector iteration in the case, the corrector has
                  to be repeated.
   saved[11][i]   is used to hold the derivatives evaluated at
                  y(i)+d and t, where d is the increment used in the
                  numerical differencing scheme invoked, in order to
                  obtain approximate values of the partial
                  derivatives.
   saved[12][i]   is used to hold the derivatives evaluated at y(i)
                  and t in order to obtain approximate values of the
                  partial derivatives.

   n        the number of first order differential equations to be
            integrated.  n may be decreased on subsequent calls if
            the number of active equations decreases, with the
            first ones being those retained.  But, it must
            not be increased without using stint3() and stint0()
            to free and then reallocate the workspace. jstart must
            then be set to zero (stint1() does this).

   t        the independent variable.  On entry t is the current
            setting of the independent variable.  On return to the
            calling program (stint1()), t corresponds to the setting
            of the independent variable for the most forward point
            obtained thus far.

   y        an n by 8 by 4 array containing the dependent variables
            and their backward differences.  On each call up to four
            solution points are obtained. The most forward point is
            always at y[0][0][i]. The point next to the most forward
            point is returned in y[0][kflag-1][i]. The most backward
            point in the new block is returned in y[0][1][i]. Only the
            initial solution values, entered in y[0][0][i] for
            i=0,...,n-1, need to be supplied on the first
            call (jstart = 0).  stint1() does this.
            y[j][k-1][i] contains the j-th backward difference of the
            i-th dependent variable (for k=1,...,kflag).
            If it is desired to interpolate to non-mesh points,
            these values can be used.  If the current step-size is
            h and the value at t-e (0 < abs(e) < abs(h)) is
            needed, form s = e/h and then compute
                           nq
              y[i](t-e) = sum y[j][k-1][i] * b[j]
                          j=0
            where k, which corresponds to t, is the first mesh point
            beyond the point t-e, and b[j] = b[j-1] * (j-s)/(j+1)
            with b[-1] = 1.

   ydot     an n by 4 array.  ydot[k-1][i], 0 <= i < n, 1 <= k <= kflag,
            contains the derivative of the i-th dependent variable
            scaled by h.  The ydot[0][i] array need not be supplied at
            the first call (jstart = 0).

   saved    a block of at least 13*ndim double precision floating point
            locations.  Is be dimensioned as saved[13][ndim].

   h        the step-size used for the just completed bock.

   hnext    the step-size for the next block.  On the
            first call (jstart=0) the user must specify an initial
            step-size.  (Note that stint1() does this.)  A good
            estimate of its magnitude is given by
               0.2*(eps/ abs(e))**0.5,
            where e is the largest eigenvalue of the jacobian
            evaluated at the initial values of t and y.  The sign
            of the initial hnext should be positive (negative) if
            the final time is greater (less) than the initial time.
            If the initial step-size choice does not cause an error
            greater than eps, in the rms norm, it will be accepted.
            Otherwise, its magnitude will be decreased until an
            error less than eps is achieved.  stint2() automatically
            adjusts the step-size after the initial and subsequent
            calls for the step-size of largest possible magnitude.
            The magnitude may be adjusted down on any subsequent
            call.  Note--a magnitude adjustment up or a sign change
            will be ignored.

   hmin     fabs(hmin) is the minimum step-size magnitude to be
            allowed for the next integration cycle.  (On the first
            call (jstart=0),  fabs(hmin) should be chosen signif-
            icantly smaller than fabs(hnext) so as to avoid start-up
            problems if the error criterion is not met with the user
            specified hnext.)  Note--the sign of hmin is ignored.
            hmin may be changed on subsequent calls.

   hmax     fabs(hmax) is the maximum step-size magnitude to be
            allowed for the next integration cycle.  Note--if
            fabs(hmax) is less than  fabs(hmin), then the subroutine
            functions as though fabs(hmax) equals fabs(hmin). hmax
            may be changed on subsequent calls.

   eps      the error test constant.  The single step error estimate
            for y, computed as a weighted rms norm, must not exceed
            eps.  The weight for the i-th element in the error
            estimate is 1/ymax[i].  (See parameter ymax.)  The
            step-size and/or order are adjusted to achieve this.

   ymax     an array of n locations, with ymax[i], i=0 ... n-1,
            being the maximum of unity and the maximum value of
            fabs(y[i]) seen thus far.  On the first call it should
            be set to the maximum of unity and the initial value of
            fabs(y[i]).  stint1(0 does this.

   kflag    a completion code. If kflag is greater than 0,then
            kflag points have been computed. If kflag is
            -2, -3, or -4 then 2, 3, or 4 mesh points, respectively,
            have been computed with  abs(h) equal to fabs(hmin),
            but the requested error was not achieved.  Other values
            kflag can assume are as follows
             -5  the requested error was smaller than can be handled
                 for this problem.
             -6  corrector convergence could not be achieved for
                  abs(h) > abs(hmin).
             -7  the maximum order specified was too large.

   knext    after the initial call (jstart=0), the value of knext
            is the number of points to be computed during the next
            cycle.  The value is supplied for information only. The
            user cannot control the number of points by setting
            knext.

   jstart   an input indicator with the following meanings
            == 0   initialization call.  (jstart must be set to 0
                    on the first call.)
            >  0   continue from the last step.
            on return jstart is set to nq, the maximum backward
            difference available in the y array.  (This also corres-
            ponds to the order of the method used to compute the
            just completed block of points.)

   maxord   the maximum order (1 <= maxord <= 7) that may be used.
            Note--if maxord is reset between cycles to a value less
            than the order determined for the next cycle, then the
            order may for several cycles exceed maxord.  However,
            it cannot exceed the above determined value and, once
            the order is less than or equal to maxord, it cannot
            then exceed maxord.

   rj       a block of at least n**2 double precision floating point
            locations, which contains an estimate of the jacobian
            of the differential equation.  Is dimensioned as
	    rj[n * n].

   rw       a block of at least n**2 double precision floating point
            locations.  Is dimensioned as rj[n * n].

   ipiv     a block of at least n integers used to hold pivot data
            generated during an LU decomposition.

   mf       method flag.  It determines the mode by which the partial
            derivatives are obtained with the following meanings
            == 1  analytic expressions for the partial derivatives are
                  supplied by the user in the subroutine jacob.
            == 2  the analytic expressions are not available.
                  approximate values of the partial derivatives are
                  obtained by numerical differencing.
*/
{  /* --- start of function stint2 --- */

double cond;

extern int    nstep, ninvs;
static double bnd, crate, d, df, di;
static double d1, d2, d3, e, edown, enqdwn, enqsam;
static double enqup, es, eup, fn;
static double hnew, hold, q, ratio, rc, rmax;
static double rrdown, rrsame, rrup;
static double tdl, told, yj1;
static double temp;
static int    iweval, ifail;
static int    newq, nqold, nq, nqp1, nqm1, neq, nqst;
static int    indbb, indb, indc, indcc;
static int    isw1, isw2, iret;
static int    ist, idel, ieq, ind, ier, dflag;
static int    i, j, j0, j1, j2;
static double pdold;
double temp1, temp2, temp3, temp4;

/*--------- start of the working part of the code --------------
--- on the first call jstart = 0, on subsequent calls jstart > 0
*/
(*kflag) = 0;
ifail = 0;
if ((*jstart) != 0) goto L80;

/* --- initialization --- first call */

fn = (double)n;
iweval = 1;
tdl = (*t);
temp1 = fabs(hmin);
temp2 = fabs(*hnext);
temp3 = fabs(hmax);
temp2 = MIN(temp2, temp3);
(*h) = MAX(temp1, temp2);
if ((*hnext) < 0.0) (*h) = -(*h);

/* --- Start afresh with order 1 method ... */
L30:

nqold = 0;
isw1 = 0;
isw2 = 0;
crate = 1.0;
(*deriv) (n, (*t), y[0][0], ydot[0]);
++(*nfe);
for (i = 0; i < n; ++i)  ydot[0][i] = (*h) * ydot[0][i];
nq = 1;
ist = 1;
idel = 0;
goto L180;

/* --- continue with the step-size h --- */
L80:

temp1 = fabs(hmin);
temp2 = fabs(hnew);
temp3 = fabs(*hnext);
temp4 = fabs(hmax);
temp3 = MIN(temp3, temp4);
temp2 = MIN(temp2, temp3);
hnew = MAX(temp1, temp2);
if ((*h) < 0.0) hnew = -hnew;
if ((*h) == hnew)
   { /* --- use the old step-size */
   ist = nqp1;
   idel = nqp1;
   isw2 = 0;
   }
else
   { /* --- new step-size --- interpolate for new points */
   ratio = hnew / (*h);
   (*h) *= ratio;
   rc *= ratio * (pd[nq-1] / pdold);
   pdold = pd[nq-1];
   if (nq != 1)
      {
      ieq = neq;
      d = 0.0;
      for (j = 2; j <= nq; ++j)
	 {
         d += ratio;
         if (d > (neq+nqp1-ieq)) ieq = 2;
         d1 = (neq-ieq-1) - d;
         for (i = 0; i < n; ++i)
	    {
            d2 = 1.0;
            d3 = 0.0;
            for (j1 = 2; j1 <= nqp1; ++j1)
	       {
               d2 *= (j1 + d1) / (j1-1);
               d3 += d2 * y[j1-1][ieq-1][i];
               }
            y[j-1][0][i] = d3 + y[0][ieq-1][i];
            }
         }
      }  /* end if */

   ist = nq;
   idel = 0;
   for (i = 0; i < n; ++i)  ydot[0][i] *= ratio;
   iret = 3;
   goto L4000;
   }   /* endif */

/* --- initialize saved array --- */
L180:

for (i = 0; i < n; ++i)
   {
   saved[8][i] = ydot[0][i];
   for (j = 0; j < ist; ++j)  saved[j][i] = y[j][0][i];
   }
nqst = nq;
ratio = 1.0;
told = (*t);
hold = (*h);

L220:

if ((nq != nqold) || (fn != n))
   {
   if ((nq != nqold) || (fn == n))
      {
      if (maxord >= 8)
	 { /* --- maximum order specified is too large
	      --- bail out */
         (*kflag) = -7;
         j1 = nqst + 1;
         for (i = 0; i < n; ++i)
	    {
            ydot[0][i] = saved[8][i];
            for (j = 0; j < j1; ++j) y[j][0][i] = saved[j][i];
            }
         (*h) = hold;
         (*t) = told;
         (*jstart) = nqst;
         return (0);
         }  /* endif */

      L260:

      /* --- set appropriate parameters and constants
             for new cycle of order nq
         --- NOTE that this is used as an entry point (VERY naughty)
             once the backward differences are formed   */
      indb = index[nq-1][0];
      indc = index[nq-1][1];
      neq = 3 + nq / 5;
      (*jstart) = nq;
      nqold = nq;
      nqm1 = nq - 1;
      nqp1 = nq + 1;
      q = (double)nq;
      enqdwn = 0.5 / q;
      enqsam = 0.5 / (q + 1.0);
      enqup = 0.5 / (q + 2.0);
      }  /* endif */
   fn = (double)n;
   temp = perr[nq-1] * eps;
   edown = fn * temp * temp;
   temp = perr[nq+2-1] * eps;
   eup = fn * temp * temp;
   temp = perr[nqp1-1] * eps;
   es = fn * temp * temp;
   if (edown <= 0.0)
      {  /* --- the error tolerance requested for this problem is
                too small  */
      (*kflag) = -5;
      j1 = nqst + 1;
      for (i = 0; i < n; ++i)
	 {
	 ydot[0][i] = saved[8][i];
         for (j = 0; j < j1; ++j)  y[j][0][i] = saved[j][i];
	 }
      (*h) = hold;
      (*t) = told;
      (*jstart) = nqst;
      return (0);
      }  /* endif */
   }  /* endif */

/* --- check for reevaluation of jacobian */
if (iweval <= 0)
   {
   if (fabs(rc-1.0) >= 0.4) iweval = 2;
   if ((tdl-told) * (*h) <= 0.0)
      {
      if (fabs(rc-1.0) >= 0.8) iweval = 1;
      }
   }
L320:
indbb = indb;
indcc = indc;
for (ieq = 1; ieq <= neq; ++ieq)
   {
   ist = ieq % neq + 1;     /* the remainder is used */
   (*t) += (*h);
   temp = pc[indcc-1] * enqup * eps;
   bnd = fn * temp * temp;
   e = es;
   if (ieq > 2)
      {
      temp = pc[indcc-1] * eps;
      e = fn * temp * temp;
      }

   /* predict y and dy for the next mesh point */

   for (i = 0; i < n; ++i)
      {
      d = ydot[ieq-1][i];
      d1 = y[0][ieq-1][i] + q * d;      /* explicit euler ?? */
      d2 = b[indbb+nqm1-1] * d;
      if (nq > 2)
	 {
         if (ieq > 3) d2 += b[indbb+nqp1-1] * ydot[2][i];
         if (ieq >= 3) d2 += b[indbb+nq-1] * ydot[1][i];
         }

      if (nq >= 2)
	 {
         for (j = 1; j < nq; ++j)
            {
	    d = y[j][ieq-1][i];
            d3 = (double) j;
            d1 += d * (d3 - q) / d3;
            d2 += d * b[indbb+j-2];
            }
         }
      y[0][ist-1][i] = d1;
      ydot[ist-1][i] = d2;
      }

   if (nq > 2)
      {
      if (ieq > 1) indbb += nq + ieq - 2;
      }

   /* iterate the corrector up to three times. accumulate the
   correction terms in saved[10][i] for redoing the entire
   corrector if convergence is not achieved  */

   d1 = c[indcc-1];
   L500:
   for (i = 0; i < n; ++i)  saved[10][i] = 0.0;
   for (j = 1; j <= 3; ++j)
      {
      /* first, evaluate the derivative at the guessed point
      NOTE that the passing of addresses to sections of the
      large arrays depends on the way tha compiler stores
      vectors and arrays.  Here, we have assumed that the
      multidimensioned arrays are stored as rows.        */

      (*deriv) (n, (*t), y[0][ist-1], saved[9]);
      ++(*nfe);

      if (iweval == 1)
         {  /* evaluate the Jacobian */
	 ind = 1;
         if (ieq == 2) ind = 1;   /* this seems useless */

         if (mf == 2)
            {   /* evaluate partial derivatives using finite differences */
	    temp = (*t) - (*h) * (1+ieq-ind);
            (*deriv) (n, temp, y[0][ind-1], saved[12]);
            ++(*nfe);
            d = 0.0;
            for (i = 0; i < n; ++i)
               {
               temp = saved[12][i];
               d += temp * temp;
               }
            d =  fabs(*h) * 1.0e3 * uround * sqrt(d);
            ++(*nje);
            for (j1 = 0; j1 < n; ++j1)
               {  /* compute differences wrt y[j1] */
	       di = sqrtur * ymax[j1];
               di = MAX(di, d);
               yj1 = y[0][ind-1][j1];     /* save present value */
               y[0][ind-1][j1] += di;
	       temp = (*t) - (*h) * (1+ieq-ind);
               (*deriv) (n, temp, y[0][ind-1], saved[11]);
               ++(*nfe);
               for (i = 0; i < n; ++i)
                  rj[i * ndim + j1] = (saved[11][i] - saved[12][i]) / di;
               y[0][ind-1][j1] = yj1;    /* restore value */
               }
            }
         else
            {  /* evaluate the jacobian directly */
	    temp = (*t) - (*h) * (1+ieq-ind);
            (*jacob) (n, temp, y[0][ind-1], rj);
            ++(*nje);
            }
         }

      if (iweval >= 1)
         {
	 d = d1 * (*h);
         for (i = 0; i < n; ++i)
	    for (j1 = 0; j1 < n; ++j1)
               rw[j1 * ndim + i] = rj[j1 * ndim + i] * d;
         for (i = 0; i < n; ++i)   rw[i * ndim + i] += 1.0;
         /* dec (n, rw, ipiv, &ier); */
	 decomp (n, ndim, rw, &cond, ipiv, &dflag);
	 ier = (cond >= 1.0e32);
         ++ninvs;
         iweval = -ieq;
         rc = 1.0;
         pdold = pd[nq-1];
         /* do we have problems with the matrix being singular? */
         if (ier != 0) goto L800;
         }

      L680:
      for (i = 0; i < n; ++i)
	 saved[9][i] = ydot[ist-1][i] - (*h) * saved[9][i];
      /* sol (n, rw, &saved[9], ipiv); */
      solve (n, ndim, rw, saved[9], ipiv);
      d2 = 0.0;
      for (i = 0; i < n; ++i)
	 {
         saved[10][i] += saved[9][i];
         y[0][ist-1][i] += d1 * saved[9][i];
         ydot[ist-1][i] -= saved[9][i];
         temp = saved[9][i] / ymax[i];
         d2 += temp * temp;
	 }
      if (j != 1) crate = MAX(crate * 0.9, d2/d3);
      temp1 = MIN(1.0, 2.0 * crate);
      if (d2 * temp1 <= bnd) goto L940;  /* converged ? */
      d3 = d2;
      }


   /* --- If we reach this point then ...
   Corrector failed to converge in three iterations.
   If jacobian was reevaluated during this cycle, step-size is
   reduced to 3/10 of h. Otherwise, jacobian is reevaluated  */

   tdl = told;
   if (iweval == 0)
      {
      for (i = 0; i < n; ++i)
	 {
         d = saved[10][i];
         y[0][ist-1][i] -= d1 * d;
         ydot[ist-1][i] += d;
	 }
      iweval = 1;
      /* now reapply the corrector  */
      goto L500;
      }


   L800:
   if (fabs(*h) <= (1.00001 * fabs(hmin)))
      {
      if (nq < 2)
	 {
         /* We have tried the lowest order method and have found
         that the corrector tolerance could not be obtained
         with abs(h) > abs(hmin)   --- bail out ...  */
         (*kflag) = -6;
         j1 = nqst + 1;
         for (i = 0; i < n; ++i)
	    {
            ydot[0][i] = saved[8][i];
            for (j = 0; j < j1; ++j) y[j][0][i] = saved[j][i];
            }
         (*h) = hold;
         (*t) = told;
         (*jstart) = nqst;
         return (0);
	 }
      else if (nq == 2)
	 {
         /* start over with order one method  */
         ifail = 0;
         for (i = 0; i < n; ++i)  y[0][0][i] = saved[0][i];
         (*t) = told;
	 temp1 = fabs(hmin/(*h));
         (*h) *= MAX(0.1, temp1);
         iweval = 2;
         goto L30;
	 }
      else
	 {
         nq = 2;
         ifail = 0;
         iret = 2;
         iweval = 2;
         goto L3000;
         }
      }
   ratio *= 0.3;
   iret = 1;
   isw1 = 0;
   isw2 = 1;
   iweval = 2;
   goto L3000;

   /*  corrector converged. the backward differences of order
   one through nq at the new mesh point are computed  */

   L940:
   /* the (nq+1)-st backward difference for all but the first
   mesh point is established  */

   for (i = 0; i < n; ++i)
      {
      for (j = 1; j <= nq; ++j)
	 y[j][ist-1][i] = y[j-1][ist-1][i] - y[j-1][ieq-1][i];
      if (ieq != 1)
         saved[9][i] = y[nqp1-1][ist-1][i] - y[nqp1-1][ieq-1][i];
      }

   if (ieq != neq)
      {
      if ((nq > 2) && ((ieq > 1) || (nq == 6))) ++indcc;
      if (ieq == 1) continue;  /* do not do the following error test */
      }

   /* error test for all but the first mesh point is performed  */

   d = 0.0;
   for (i = 0; i < n; ++i)
      {
      temp = saved[9][i] / ymax[i];
      d += temp * temp;
      }

   if (d > e)
      {
      /* the error criterion was not met  */
      ++ifail;
      if (ifail <= 2)
	 {
         if (fabs(*h) <= (fabs(hmin) * 1.00001))
	    {
            if (nq < 2)
	       {
               /* We can't do much better -- just accept the points
               computed with the smallest step-size --- bail out ...
	       */
               iweval = 0;
               nstep += ieq;
               (*kflag) = -ieq;
               return (0);
               }
            else if (nq == 2)
               {
               /* drop order to one and try again  */
               nq = 1;
               ifail = 0;
               iret = 2;
               iweval = 2;
               goto L3000;
               }
            else
               {
               /* drop the high order method to order 2
               and try again  */
               nq = 2;
               ifail = 0;
               iret = 2;
               iweval = 2;
               goto L3000;
               }
            }
         iweval = 2;
         if (ifail == 1) goto L1200;
         tdl = (*t);
         ratio *= 0.5;
         iret = 1;
         isw1 = 0;
         isw2 = 1;
         goto L3000;
         }

      /* start over with order 1 method  */
      ifail = 0;
      for (i = 0; i < n; ++i)  y[0][0][i] = saved[0][i];
      (*t) = told;
      temp1 = fabs(hmin/(*h));
      (*h) *= MAX(0.1, temp1);
      iweval = 2;
      goto L30;
      }

   }   /* end of big loop */

iweval = 0;
e = es;
(*kflag) = neq;
nstep += (*kflag);
hnew = (*h);

/* check for continuation with the same h and nq  */

if (isw2 == 1)
   {
   for (i = 0; i < n; ++i)
      {
      d = ymax[i];
      for (j = 0; j < neq; ++j)
	 {
	 temp1 = fabs(y[0][j][i]);
	 d = MAX(d, temp1);
	 }
      ymax[i] = d;
      }
   (*hnext) = hnew;
   (*knext) = 3 + nq / 5;
   return (0);
   }
if (nq > 3) isw1 = 1 - isw1;
if (isw1 == 1)
   {
   for (i = 0; i < n; ++i)
      {
      d = ymax[i];
      for (j = 0; j < neq; ++j)
	 {
	 temp1 = fabs(y[0][j][i]);
	 d = MAX(d, temp1);
	 }
      ymax[i] = d;
      }
   (*hnext) = hnew;
   (*knext) = 3 + nq / 5;
   return (0);
   }

/* new step-size and/or order selection  */

L1200:
temp = fabs (d / e);
rrsame = 1.2 * pow(temp, enqsam);
if (ifail != 0)
   {
   ratio /= rrsame;
   iret = 1;
   isw1 = 0;
   isw2 = 1;
   goto L3000;
   }
rmax = 1.0e-4;
df = (double) (neq + nqm1);
if (nq != 1) rmax = (q - 1.0) / df;
rrsame = MAX(rrsame, rmax);
rrup = 1.0e20;
rrdown = 1.0e20;
if (nq < maxord)
   {
   d = 0.0;
   for (i = 0; i < n; ++i)
      {
      d1 = y[nqp1-1][neq-1][i] - y[nqp1-1][neq-1-1][i];
      temp = (saved[9][i] - d1) / ymax[1];
      d += temp * temp;
      }
   temp = fabs (d / eup);
   rrup = 1.2 * pow(temp, enqup);
   rmax = q / df;
   rrup = MAX(rrup, rmax);
   }

if (nq != 1)
   {
   d = 0.0;
   for (i = 0; i < n; ++i)
      {
      temp = y[nqp1-1][0][i] / ymax[i];
      d += temp * temp;
      }
   temp = fabs (d / edown);
   rrdown = 1.2 * pow(temp, enqdwn);
   rmax = 1.0e-4;
   if (nq != 2) rmax = (q - 2.0) / df;
   rrdown = MAX(rrdown, rmax);
   }

if (rrsame > rrup)
   {
   if (rrup < rrdown)
      {
      newq = nqp1;
      d = 1.0 / rrup;
      }
   else
      {
      newq = nqm1;
      d = 1.0 / rrdown;
      }
   }
else if (rrsame <= rrdown)
   {
   newq = nq;
   d = 1.0 / rrsame;
   }
else
   {
   newq = nqm1;
   d = 1.0 / rrdown;
   }

if (d > 1.1)
   {
   hnew = (*h) * d;
   nq = newq;
   }

for (i = 0; i < n; ++i)
   {
   d=ymax[i];
   for (j = 0; j < neq; ++j)
      {
      temp1 = fabs(y[0][j][i]);
      d = MAX(d, temp1);
      }
   ymax[i] = d;
   }
(*hnext) = hnew;
(*knext) = 3 + nq / 5;
return (0);

/*------------------- effective end of routine ----------------------*/


/* The following section is used when step-size or order is changed
during the cycle.  starting values are retrieved from the
saved array.
When jumping to this section of code the return flag indicates ...
iret = 1 : go back and compute more mesh points
       2 : start a new cycle of order nq
       3 : reset the saved array and start a new cycle of order nq
*/

L3000:
temp1 = fabs(hmin/hold);
temp2 = MIN(ratio, 1.0);
ratio = MAX(temp1, temp2);
(*t) = told;
if (ratio >= 1.0)
   {
   for (i = 0; i < n; ++i)
      {
      ydot[0][i] = saved[8][i];
      for (j = 0; j < nq; ++j)  y[j][0][i] = saved[j][i];
      }
   if (iret == 1) goto L320;
   if (iret >= 2) goto L260;
   }
else if (idel <= 0)
   {
   /* the (nqst+1)-st order backward difference is established  */
   idel = nqst + 1;
   if ((nqst >= 2) && (nq >= 2))
      {
      d = (double) nqst;
      for (i = 0; i < n; ++i)
	 {
         d1 = saved[8][i];
         for (j = 1; j < nqst; ++j)  d1 -= saved[j][i] / j;
         saved[idel-1][i] = d * d1;
	 }
      }
   }

/* interpolate for new points  */

for (i = 0; i < n; ++i)
   {
   ydot[0][i] = ratio * saved[8][i];
   if (nq >= 2)
      {
      d1 = 0.0;
      for (j = 2; j <= nq; ++j)
	 {
         d1 += ratio;
         d2 = 1.0;
         d = 0.0;
         for (j1 = 1; j1 < idel; ++j1)
	    {
            d2 *= (j1 - 1.0 - d1) / j1;   /* check that this
						   gives
						   correct result !! */
            d += d2 * saved[j1][i];
	    }
         y[j-1][0][i] = d + saved[0][i];
	 }
      y[0][0][i] = saved[0][i];
      }
   }
(*h) = hold * ratio;

/* form the backward differences */

L4000:
if (nq >= 2)
   {
   nqm1 = nq - 1;
   for (i = 0; i < n; ++i)
      {
      for (j = 1; j <= nqm1; ++j)
	 {
         j0 = j + 1;
         for (j1 = j0; j1 <= nq; ++j1)
	    {
            j2 = nq - j1 + j;
            y[j2][0][i] = y[j2-1][0][i] - y[j2][0][i];
	    }
	 }
      }
   }

if (iret == 1) goto L320;
if (iret == 2) goto L260;
if (iret == 3) goto L180;

return (0);
}   /* end of function stint2 */

/*-----------------------------------------------------------------*/

#if (PROTOTYPE)

int stint3 (void)

#else

int stint3 ()

#endif

/* Purpose ...
   -------
   Clean-up after using stint0(), stint1() and stint2().
*/

{
int i, j;

if (ipiv != NULL) { free (ipiv); ipiv = NULL; }

if (ymax != NULL) { free (ymax); ymax = NULL; }

if (rw   != NULL) { free (rw); rw = NULL; }

if (rj   != NULL) { free (rj); rj = NULL; }

if (saved != NULL)
   {
   for (j = 0; j < 13; ++j)
      {
      if (saved[j] != NULL) { free (saved[j]); saved[j] = NULL; }
      }
   free (saved);
   saved = NULL;
   }

if (ydot != NULL)
   {
   for (j = 0; j < 4; ++j)
      {
      if (ydot[j] != NULL) { free (ydot[j]); ydot[j] = NULL; }
      }
   free (ydot);
   ydot = NULL;
   }

if (y != NULL)
   {
   for (i = 0; i < 8; ++i)
      {
      if (y[i] != NULL)
         {
         for (j = 0; j < 4; ++j)
            {
            if (y[i][j] != NULL) { free (y[i][j]); y[i][j] = NULL; }
            }
         free (y[i]);
         y[i] = NULL;
         }
      }
   free (y);
   y = NULL;
   }

return (0);
}

/*-----------------------------------------------------------------*/
@
